

### 地址栏输入url 发生了什么

首先会进行 url 解析，根据 dns 系统进行 ip 查找

根据 ip 就可以找到服务器，然后浏览器和服务器会进行 TCP 三次握手建立连接，如果此时是 https 的话，还会建立 TLS 连接以及协商加密算法

连接建立之后浏览器开始发送请求获取文件，此时这里还会出现一种情况就是缓存，建立连接后是走缓存还是直接重新获取，需要看后台设置，所以这里会有一个关注的问题"浏览器缓存机制"，缓存我们等会在讲，现在我们就当没有缓存，直接去获取文件。

### 浏览器解析过程

首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点。

解析到了 html 头部发现有 css 文件，此时下载 css 文件，css 文件也是一边下载一边解析的，构建的是 CSSOM 树，当 DOM 树和 CSSOM 树全部构建完之后，浏览器会把 DOM 树和 CSSOM 树构建成渲染树。

构造渲染树的时候还做了哪些事情。第一个就是样式计算，DOM树 和 CSSOM树有了之后，浏览器开始样式计算，主要是为 DOM 树上的节点找到对应的样式。

构建布局树，样式计算完之后就开始构建布局树。主要是为 DOM 树上的节点找到页面上对应位置以及一些"display:none"元素的隐藏。

构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，z-index，position 这些复杂的分层操作。

将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染

最终渲染进程将整个页面渲染出来，在渲染的过程中会还出现重排和重绘

### 重排重绘为什么会影响渲染，如何避免?

重绘

重绘指的是不影响界面布局的操作，比如更改颜色，那么根据上面的渲染讲解我们知道，重绘之后我们只需要在重复进行一下样式计算，就可以直接渲染了，对浏览器渲染的影响相对较小

重排

重排指的是影响界面布局的操作，比如改变宽高，隐藏节点等。对于重排就不是一个重新计算样式那么简单了，因为改变了布局，根据上面的渲染流程来看涉及到的阶段有样式计算，布局树重新生成，分层树重新生成，所以重排对浏览器的渲染影响是比较高的

- 避免方法

- - js 尽量减少对样式的操作，能用 css 完成的就用 css
  - 对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用
  - 如果必须要用 js 操作样式，能合并尽量合并不要分多次操作
  - resize 事件 最好加上防抖，能尽量少触发就少触发
  - 加载图片的时候，提前写好宽高

### 浏览器缓存机制

#### 缓存方式

一种是强制缓存，一种是协商缓存

强制缓存

强制缓存就是文件直接从缓存中获取，不需要发送请求

协商缓存

协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置，下面会说到。需要注意的是协商缓存还是发了请求的

#### 缓存实现

- 强制缓存

强制缓存在 http1.0 的时候用的是 Expires，是响应头里面的一个字段表示的是文件过期时间。是一个绝对时间，正因为是绝对时间所以在某些情况下，服务器的时区和浏览器时区不一致的时候就会导致缓存失效。为了解决这个问题，HTPP1.1 引入了一个新的响应头 cache-control 它的可选值如下

##### cache-control

- max-age: 缓存过期时间，是一个相对时间
- public: 表示客户端和代理服务器都会缓存
- private: 表示只在客户端缓存
- no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
- no-store: 表示文件不会被缓存

HTTP1.1 利用的就是 max-age:600 来强制缓存，因为是相对时间，所以不会出现 Expires 问题

- 协商缓存

  协商缓存是利用 Last-Modified/if-Modified-Since,Etag/if-None-Match 这两对请求、响应头。

  ##### Last-Modified/if-Modified-Since

  ##### Etag/If-None-Match

  由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以HTTP1.1又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如"W/"5f9583bd-10a8""，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过

- - 浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个 if-Modified-Since，记录被改动的时间
  - 浏览器第二次发送请求的时候会带上一个 Last-Modified 请求头，时间就是 if-Modified-Since 返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回 304 从缓存里面获取文件

## 请求优化

### 减少请求数量

将小图片打包成base64

利用雪碧图融合多个小图片

利用缓存上面已经说到过

### 减少请求时间

将js，css，html等文件能压缩的尽量压缩，减少文件大小，加快下载速度

利用webpack打包根据路由进行懒加载，不要初始就加载全部，那样文件会很大

建立内部CDN能更快速的获取文件



## 前端性能优化

